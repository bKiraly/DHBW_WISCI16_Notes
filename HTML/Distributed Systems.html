<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Distributed Systems</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#distributed-systems">Distributed Systems</a>
<ul>
<li><a href="#aims-of-distributed-systems">Aims of distributed systems</a></li>
<li><a href="#communication-in-distributed-systems">Communication in distributed systems</a></li>
<li><a href="#security">Security</a></li>
<li><a href="#fault-tolerance">Fault tolerance</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="distributed-systems">Distributed Systems</h1>
<h2 id="aims-of-distributed-systems">Aims of distributed systems</h2>
<ul>
<li>Performance
<ul>
<li>0.1s loading time considered immediate</li>
<li>Compose web page from multiple distributed sources</li>
<li>Load balancing</li>
<li>Scaling</li>
</ul>
</li>
<li>Costs
<ul>
<li>Avoid overhead</li>
<li>Light-weight</li>
<li>Multi tenancy</li>
<li>Scaling</li>
<li>Pay as you go</li>
</ul>
</li>
<li>Availability
<ul>
<li>Redundancy</li>
<li>Fail over</li>
<li>Load balancing</li>
<li>Monitoring</li>
<li>Timeouts</li>
</ul>
</li>
<li>Security
<ul>
<li>Authentication</li>
<li>Authorization</li>
<li>Encryption</li>
<li>Defense in depth</li>
<li>Monitoring</li>
<li>Backups</li>
<li>Planning</li>
</ul>
</li>
<li>Manageability
<ul>
<li>Monitoring</li>
<li>Instrumenting</li>
<li>Updates</li>
<li>Changes/Migrations</li>
</ul>
</li>
<li>Scalability
<ul>
<li>Monitor loads</li>
<li>Scale up to demand</li>
<li>Scale down to reduce costs</li>
<li>Bigger changes (shard DB)</li>
</ul>
</li>
</ul>
<h2 id="communication-in-distributed-systems">Communication in distributed systems</h2>
<ul>
<li>Point to Point</li>
<li>Localized multicast</li>
<li>Types
<ul>
<li>Request-Response (stateless)</li>
<li>WebSockets</li>
<li>Streaming</li>
</ul>
</li>
<li>Text-based
<ul>
<li>Plaintext</li>
<li>HTML</li>
<li>JSON</li>
<li>XML</li>
<li>YAML</li>
<li>Etc.</li>
</ul>
</li>
<li>Binary
<ul>
<li>BSON</li>
<li>Colfer</li>
<li>Hessian</li>
<li>Apache Avro</li>
</ul>
</li>
</ul>
<h2 id="security">Security</h2>
<p>Problems</p>
<ul>
<li>Confidentiality - Keep data from unauthorized access</li>
<li>Integrity - prevent unauthorized change of data</li>
<li>Availability - Ability to access data</li>
<li>Non-reprudiation - Prevent future deniability</li>
</ul>
<p>Solutions</p>
<ul>
<li>Symmetric encryption
<ul>
<li>Single key</li>
<li>Fast</li>
<li>Key distribution</li>
<li>Chaining</li>
<li>Integrity</li>
<li>Example: AES</li>
<li>Chaining
<ul>
<li>The previous block influences the next block -&gt; Repetitions eliminated</li>
<li>+Nonce +Counter -&gt; Counter mode (CTR)</li>
</ul>
</li>
</ul>
</li>
<li>Asymmetric encryption
<ul>
<li>2 keys</li>
<li>One for encryption, one for decryption</li>
<li>RSA</li>
<li>Rely on prime factorization</li>
<li>One has to verify the public key actually corresponds to the person
<ul>
<li>PKI
<ul>
<li>Users trust CA</li>
<li>CA issues certificate to site</li>
<li>Site present certificate</li>
<li>CAs can be hacked</li>
</ul>
</li>
<li>PGP / GPG
<ul>
<li>Simple public key as text</li>
<li>Often used for e-mails</li>
<li>Key exchange parties</li>
</ul>
</li>
<li>Personal exchange</li>
<li>Blockchain
<ul>
<li>BTC wallet is a private key</li>
<li>Public key is identifier</li>
</ul>
</li>
<li>Hashing
<ul>
<li>One-way encryption</li>
<li>SHA512, ARGON</li>
<li><strong>DO NOT USE:</strong> MD5, SHA1</li>
</ul>
</li>
</ul>
</li>
<li>OAuth
<ul>
<li>Identity provider controls all identities</li>
<li>Easy for the user</li>
<li><code>Login with google</code> button works that way</li>
</ul>
</li>
<li>Secure Remote Password
<ul>
<li>Store a hash of the password and salt</li>
<li>Prove knowledge of password using DH</li>
<li>Produce session key</li>
<li>No plaintext password revealed to the server</li>
</ul>
</li>
<li>Trusted timestamping
<ul>
<li>Trusted third party signs the timestamp</li>
</ul>
</li>
<li>Key splitting
<ul>
<li>N of M systems</li>
<li>Calculate M keys based on the original</li>
<li>N of them needed to get the original secret</li>
</ul>
</li>
<li>Cryptography – easy on the surface, difficult when you dig down.
<ul>
<li>Small mistakes can compromise security</li>
<li><strong>Stick to existing solutions</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="distribution-transparency">Distribution transparency</h3>
<blockquote>
<p><strong>Transparency</strong> is the idea of hiding certain information, in order to make it look as though the distributed system was one unified whole.</p>
</blockquote>
<ul>
<li>Access</li>
<li>Location</li>
<li>Migration</li>
<li>Relocation</li>
<li>Replication</li>
<li>Concurrency</li>
<li>Failure</li>
</ul>
<h3 id="openness">Openness</h3>
<ul>
<li>Using standard syntax and semantics</li>
<li>Interfaces – IDL</li>
<li>Interface semantics</li>
<li>Interoperability</li>
<li>Portability</li>
<li>Extensiblity</li>
</ul>
<h3 id="beginner-assumptions">Beginner assumptions</h3>
<ul>
<li>Network is reliable</li>
<li>Network is secure</li>
<li>Network is homogeneous</li>
<li>The topology does not change</li>
<li>Latency is zero</li>
<li>Bandwidth is infinite</li>
<li>Transport cost is zero</li>
<li>There is one admin/domain</li>
</ul>
<h3 id="virtualization">Virtualization</h3>
<ul>
<li>Runs the program in a specific environment different from the environment outside the Virtualization Manager</li>
<li>Types
<ul>
<li>Paravirtualization (e.g. JVM)</li>
<li>Bare-metal hypervisor (e.g. VMWare)</li>
<li>Hosted hypervisor (e.g. VirtualBox)</li>
</ul>
</li>
<li>Separate privileged calls from unprivileged ones</li>
<li>Solutions
<ul>
<li>Emulate all instructions</li>
<li>Warp nonprivileged instructions to divert control to the VMMs</li>
<li>Paravirtualization</li>
</ul>
</li>
<li>XaaS
<ul>
<li>Infrastructure as a Service</li>
<li>Platform as a Service</li>
<li>Software as a Service</li>
</ul>
</li>
</ul>
<h3 id="networked-ui">Networked UI</h3>
<ul>
<li>X-window
<ul>
<li>Each application is a client to the X-server</li>
<li>They use the X-protocol to communicate with the X-server</li>
<li>The X-server displays the image on the terminal</li>
</ul>
</li>
</ul>
<h3 id="server-architecture">Server architecture</h3>
<ul>
<li>Iterative vs Concurrent servers
<ul>
<li>Iterative server
<ul>
<li>The server goes through each request one-by-one</li>
</ul>
</li>
<li>Concurrent servers
<ul>
<li>The server creates a separate thread for each process</li>
</ul>
</li>
</ul>
</li>
<li>Stateful vs Stateless servers
<ul>
<li>Stateful servers
<ul>
<li>Keeps track of client</li>
<li>Efficient</li>
<li>Fragile</li>
</ul>
</li>
<li>Stateless server
<ul>
<li>Does not keep track of client</li>
<li>Inefficiencies</li>
<li>Robust</li>
</ul>
</li>
<li>Distributed systems
<ul>
<li>Entry system</li>
<li>Load balancing</li>
<li>Processing servers</li>
<li>Database servers</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="messaging">Messaging</h3>
<ul>
<li>Persistent vs transient messaging</li>
<li>Synchronous vs asynchronous messaging</li>
</ul>
<h3 id="rpcs">RPCs</h3>
<ul>
<li>Remote procedure calls</li>
<li>Functions on servers</li>
<li>Encoding negotiation</li>
<li>Async RPCs -&gt; callback called when the server is done</li>
</ul>
<h3 id="mpi">MPI</h3>
<ul>
<li>Used in supercomputers</li>
<li>Specific cases</li>
</ul>
<h3 id="message-oriented-middleware">Message-oriented middleware</h3>
<ul>
<li>Queue managers</li>
<li>Message brokers
<ul>
<li>Transform and relay messages based on source and destination addresses and formats</li>
</ul>
</li>
<li>Multicast (Application level)
<ul>
<li>Link stress</li>
<li>Stretch</li>
</ul>
</li>
<li>Epidemic protocols
<ul>
<li>Anti-entropy</li>
<li>Rumor spreading</li>
</ul>
</li>
</ul>
<h3 id="restful-services">RESTful services</h3>
<ul>
<li>Usually via HTTP(S)</li>
<li>Messages can be XML, JSON, etc.</li>
<li>Based on URIs</li>
<li>Resources</li>
<li>CRUD operations</li>
</ul>
<p>CRUD:<br>
-Create<br>
-Run<br>
-Update<br>
-Delete<br>
Client-Server architecture<br>
-Seperating concers<br>
-UI from processing from data storage<br>
-Better scalability<br>
-Better support for migration, update, replace</p>
<p>Statelessness</p>
<ul>
<li>No client context stored in server between requests
<ul>
<li>State stored in the client</li>
<li>Can be also in the underlying DB</li>
<li>Client sends a request when changing state<br>
Cacheability: Messages have to define wheter they are cacheable or not -&gt; Perfomance improvements<br>
Layered system:</li>
</ul>
</li>
<li>Client cannot tell if it is talking to:
<ul>
<li>Gateway</li>
<li>Authentification server</li>
<li>Load balancer</li>
<li>App server<br>
Code on demand:</li>
</ul>
</li>
<li>Server can extend client by providing code<br>
Uniform interface:</li>
<li>Resource identification in request
<ul>
<li>Resource identified directly in the URI</li>
<li>Resource representation seperate from internal</li>
</ul>
</li>
<li>Resource manipulation through representation
<ul>
<li>Resource representation has enough info to manipulate it in the server</li>
</ul>
</li>
<li>Self-descriptive messages
<ul>
<li>Each messages has enough info to process it</li>
</ul>
</li>
<li>Hypermedia As The Engine Of Application State HATEOAS</li>
</ul>
<h4 id="rest-maturity-levels">REST Maturity levels</h4>
<ol start="0">
<li>Swamp of POX
<ul>
<li>Communicate over HTTP</li>
</ul>
</li>
<li>Resources
<ul>
<li>URI path already correct</li>
</ul>
</li>
<li>Verbs
<ul>
<li>URI Parameters now correct</li>
</ul>
</li>
<li>HATEOAS
<ul>
<li>Discoverability</li>
<li>Return all resources needed for future replies</li>
</ul>
</li>
</ol>
<h4 id="advantages-of-rest">Advantages of REST</h4>
<ul>
<li>Simple service</li>
<li>No state mismatch</li>
<li>Easy load balancing</li>
<li>Easy service comparison</li>
<li>Correct verbs make service clearer</li>
</ul>
<h4 id="naming-things">Naming things</h4>
<ul>
<li>Pure name – random string</li>
<li>Identifier – A name with a  specific property</li>
<li>Flat naming</li>
<li>Broadcasting</li>
<li>ARP</li>
<li>Forwarding pointer</li>
<li>Hierarchical locations services
<ul>
<li>Create hierarchies based on geographical data</li>
<li>Keyspaces create trees</li>
</ul>
</li>
<li>Structured naming
<ul>
<li>Each level defines its namespace</li>
<li>Attach attributes to any node</li>
<li>DNS</li>
<li>NFS file name</li>
<li>Phone number</li>
<li>IP address</li>
</ul>
</li>
<li>Links
<ul>
<li>Hard link – Point to another node</li>
<li>Soft link – Contain the name of another node</li>
</ul>
</li>
<li>Mounting</li>
<li>Foreign namespaces can be mounted in a node on the root namespace</li>
<li>Name spaces can be split among multiple machines in a distributed way</li>
<li>DNS name resolution (see Communication Systems)</li>
<li>UUIDs and GUIDs
<ul>
<li>Practically unique</li>
<li>No central coordination</li>
<li>128-bit identifiers</li>
<li>RFC 4122 defines uniform resource name</li>
</ul>
</li>
</ul>
<h3 id="coordination">Coordination</h3>
<ul>
<li>Clock coordination
<ul>
<li>NTP</li>
<li>UTC</li>
<li>Reference broadcast synchronization</li>
<li>Happened-before relationships</li>
</ul>
</li>
<li>Logical locks
<ul>
<li>Lamports clocks</li>
<li>Vector locks</li>
</ul>
</li>
<li>Mutual exclusion
<ul>
<li>Lamports clocks for mutual exclusion</li>
<li>Permission based
<ul>
<li>Coordinator decides who gets the lock</li>
</ul>
</li>
<li>Token based
<ul>
<li>Token-ring overlay network</li>
</ul>
</li>
<li>Mutual exclusion Ricart &amp; Agrawala</li>
<li>Decentralized algorithms</li>
</ul>
</li>
<li>Election algorithms
<ul>
<li>Find coordinators</li>
<li>All processes have unique IDs</li>
<li>All processes know of all other processes in the system</li>
<li>Election means identifying if the process with the highest ID is up</li>
<li>Elections in ring systems
<ul>
<li>Send a message on the ring with the ID</li>
<li>It goes around, and each node adds its ID</li>
</ul>
</li>
</ul>
</li>
<li>Positioning of a node
<ul>
<li>Calculate distance to landmarks</li>
<li>GPS</li>
</ul>
</li>
</ul>
<h3 id="replication">Replication</h3>
<ul>
<li>Reasons for replication
<ul>
<li>Reliability</li>
<li>Performance</li>
</ul>
</li>
</ul>
<h4 id="consistency">Consistency</h4>
<ul>
<li>Guaranteed consistency
<ul>
<li>Locking</li>
<li>Performance problems</li>
<li>Sequence locking</li>
</ul>
</li>
<li>Eventual consistency
<ul>
<li>Relaxed</li>
<li>The changes will be replicated to other replicas</li>
<li>This is not a locking call</li>
<li>Monotonic reads</li>
</ul>
</li>
</ul>
<h4 id="content-distribution">Content distribution</h4>
<ul>
<li>Propagate notification/invalidation</li>
<li>Transfer the data</li>
<li>Propagate the update operation</li>
</ul>
<h4 id="pull-vs-push">Pull vs push</h4>
<ul>
<li>Push
<ul>
<li>Server-initiated</li>
</ul>
</li>
<li>Pull
<ul>
<li>Client initiated poll</li>
</ul>
</li>
</ul>
<h4 id="replication-methods">Replication methods</h4>
<ul>
<li>Primary based
<ul>
<li>Primary handles all the writes</li>
<li>Primary has to sign off on all writes</li>
</ul>
</li>
</ul>
<h2 id="fault-tolerance">Fault tolerance</h2>
<h3 id="goals">Goals</h3>
<ul>
<li>Partial failure != total failure</li>
<li>Ideally failure means no degradation</li>
<li>If degradation is inevitable, it should degrade gracefully</li>
<li>In the case of catastrophic failure it should fail safely</li>
</ul>
<h3 id="dependability">Dependability</h3>
<ul>
<li>Parts of a system may depend on other parts of a system</li>
</ul>
<h3 id="metrics">Metrics</h3>
<ul>
<li>Availability</li>
<li>Reliability</li>
<li>Safety</li>
<li>Maintainability</li>
</ul>

    </div>
  </div>
</body>

</html>
