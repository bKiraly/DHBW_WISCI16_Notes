<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Distributed Systems</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#distributed-systems">Distributed Systems</a>
<ul>
<li><a href="#aims-of-distributed-systems">Aims of distributed systems</a></li>
<li><a href="#communication-in-distributed-systems">Communication in distributed systems</a></li>
<li><a href="#security">Security</a></li>
<li><a href="#fault-tolerance">Fault tolerance</a></li>
</ul>
</li>
<li><a href="#exam-stuff">Exam stuff</a>
<ul>
<li></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="distributed-systems">Distributed Systems</h1>
<h2 id="aims-of-distributed-systems">Aims of distributed systems</h2>
<ul>
<li>Performance
<ul>
<li>0.1s loading time considered immediate</li>
<li>Compose web page from multiple distributed sources</li>
<li>Load balancing</li>
<li>Scaling</li>
</ul>
</li>
<li>Costs
<ul>
<li>Avoid overhead</li>
<li>Light-weight</li>
<li>Multi tenancy</li>
<li>Scaling</li>
<li>Pay as you go</li>
</ul>
</li>
<li>Availability
<ul>
<li>Redundancy</li>
<li>Fail over</li>
<li>Load balancing</li>
<li>Monitoring</li>
<li>Timeouts</li>
</ul>
</li>
<li>Security
<ul>
<li>Authentication</li>
<li>Authorization</li>
<li>Encryption</li>
<li>Defense in depth</li>
<li>Monitoring</li>
<li>Backups</li>
<li>Planning</li>
</ul>
</li>
<li>Manageability
<ul>
<li>Monitoring</li>
<li>Instrumenting</li>
<li>Updates</li>
<li>Changes/Migrations</li>
</ul>
</li>
<li>Scalability
<ul>
<li>Monitor loads</li>
<li>Scale up to demand</li>
<li>Scale down to reduce costs</li>
<li>Bigger changes (shard DB)</li>
</ul>
</li>
</ul>
<h2 id="communication-in-distributed-systems">Communication in distributed systems</h2>
<ul>
<li>Point to Point</li>
<li>Localized multicast</li>
<li>Types
<ul>
<li>Request-Response (stateless)</li>
<li>WebSockets</li>
<li>Streaming</li>
</ul>
</li>
<li>Text-based
<ul>
<li>Plaintext</li>
<li>HTML</li>
<li>JSON</li>
<li>XML</li>
<li>YAML</li>
<li>Etc.</li>
</ul>
</li>
<li>Binary
<ul>
<li>BSON</li>
<li>Colfer</li>
<li>Hessian</li>
<li>Apache Avro</li>
</ul>
</li>
</ul>
<h2 id="security">Security</h2>
<p>Problems</p>
<ul>
<li>Confidentiality - Keep data from unauthorized access</li>
<li>Integrity - prevent unauthorized change of data</li>
<li>Availability - Ability to access data</li>
<li>Non-reprudiation - Prevent future deniability</li>
</ul>
<p>Solutions</p>
<ul>
<li>Symmetric encryption
<ul>
<li>Single key</li>
<li>Fast</li>
<li>Key distribution</li>
<li>Chaining</li>
<li>Integrity</li>
<li>Example: AES</li>
<li>Chaining
<ul>
<li>The previous block influences the next block -&gt; Repetitions eliminated</li>
<li>+Nonce +Counter -&gt; Counter mode (CTR)</li>
</ul>
</li>
</ul>
</li>
<li>Asymmetric encryption
<ul>
<li>2 keys</li>
<li>One for encryption, one for decryption</li>
<li>RSA</li>
<li>Rely on prime factorization</li>
<li>One has to verify the public key actually corresponds to the person
<ul>
<li>PKI
<ul>
<li>Users trust CA</li>
<li>CA issues certificate to site</li>
<li>Site present certificate</li>
<li>CAs can be hacked</li>
</ul>
</li>
<li>PGP / GPG
<ul>
<li>Simple public key as text</li>
<li>Often used for e-mails</li>
<li>Key exchange parties</li>
</ul>
</li>
<li>Personal exchange</li>
<li>Blockchain
<ul>
<li>BTC wallet is a private key</li>
<li>Public key is identifier</li>
</ul>
</li>
<li>Hashing
<ul>
<li>One-way encryption</li>
<li>SHA512, ARGON</li>
<li><strong>DO NOT USE:</strong> MD5, SHA1</li>
</ul>
</li>
</ul>
</li>
<li>OAuth
<ul>
<li>Identity provider controls all identities</li>
<li>Easy for the user</li>
<li><code>Login with google</code> button works that way</li>
</ul>
</li>
<li>Secure Remote Password
<ul>
<li>Store a hash of the password and salt</li>
<li>Prove knowledge of password using DH</li>
<li>Produce session key</li>
<li>No plaintext password revealed to the server</li>
</ul>
</li>
<li>Trusted timestamping
<ul>
<li>Trusted third party signs the timestamp</li>
</ul>
</li>
<li>Key splitting
<ul>
<li>N of M systems</li>
<li>Calculate M keys based on the original</li>
<li>N of them needed to get the original secret</li>
</ul>
</li>
<li>Cryptography – easy on the surface, difficult when you dig down.
<ul>
<li>Small mistakes can compromise security</li>
<li><strong>Stick to existing solutions</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="distribution-transparency">Distribution transparency</h3>
<blockquote>
<p><strong>Transparency</strong> is the idea of hiding certain information, in order to make it look as though the distributed system was one unified whole.</p>
</blockquote>
<ul>
<li>Access</li>
<li>Location</li>
<li>Migration</li>
<li>Relocation</li>
<li>Replication</li>
<li>Concurrency</li>
<li>Failure</li>
</ul>
<h3 id="openness">Openness</h3>
<ul>
<li>Using standard syntax and semantics</li>
<li>Interfaces – IDL</li>
<li>Interface semantics</li>
<li>Interoperability</li>
<li>Portability</li>
<li>Extensiblity</li>
</ul>
<h3 id="beginner-assumptions">Beginner assumptions</h3>
<ul>
<li>Network is reliable</li>
<li>Network is secure</li>
<li>Network is homogeneous</li>
<li>The topology does not change</li>
<li>Latency is zero</li>
<li>Bandwidth is infinite</li>
<li>Transport cost is zero</li>
<li>There is one admin/domain</li>
</ul>
<h3 id="virtualization">Virtualization</h3>
<ul>
<li>Runs the program in a specific environment different from the environment outside the Virtualization Manager</li>
<li>Types
<ul>
<li>Paravirtualization (e.g. JVM)</li>
<li>Bare-metal hypervisor (e.g. VMWare)</li>
<li>Hosted hypervisor (e.g. VirtualBox)</li>
</ul>
</li>
<li>Separate privileged calls from unprivileged ones</li>
<li>Solutions
<ul>
<li>Emulate all instructions</li>
<li>Warp nonprivileged instructions to divert control to the VMMs</li>
<li>Paravirtualization</li>
</ul>
</li>
<li>XaaS
<ul>
<li>Infrastructure as a Service</li>
<li>Platform as a Service</li>
<li>Software as a Service</li>
</ul>
</li>
</ul>
<h3 id="networked-ui">Networked UI</h3>
<ul>
<li>X-window
<ul>
<li>Each application is a client to the X-server</li>
<li>They use the X-protocol to communicate with the X-server</li>
<li>The X-server displays the image on the terminal</li>
</ul>
</li>
</ul>
<h3 id="server-architecture">Server architecture</h3>
<ul>
<li>Iterative vs Concurrent servers
<ul>
<li>Iterative server
<ul>
<li>The server goes through each request one-by-one</li>
</ul>
</li>
<li>Concurrent servers
<ul>
<li>The server creates a separate thread for each process</li>
</ul>
</li>
</ul>
</li>
<li>Stateful vs Stateless servers
<ul>
<li>Stateful servers
<ul>
<li>Keeps track of client</li>
<li>Efficient</li>
<li>Fragile</li>
</ul>
</li>
<li>Stateless server
<ul>
<li>Does not keep track of client</li>
<li>Inefficiencies</li>
<li>Robust</li>
</ul>
</li>
<li>Distributed systems
<ul>
<li>Entry system</li>
<li>Load balancing</li>
<li>Processing servers</li>
<li>Database servers</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="messaging">Messaging</h3>
<ul>
<li>Persistent vs transient messaging</li>
<li>Synchronous vs asynchronous messaging</li>
</ul>
<h3 id="rpcs">RPCs</h3>
<ul>
<li>Remote procedure calls</li>
<li>Functions on servers</li>
<li>Encoding negotiation</li>
<li>Async RPCs -&gt; callback called when the server is done</li>
</ul>
<h3 id="mpi">MPI</h3>
<ul>
<li>Used in supercomputers</li>
<li>Specific cases</li>
</ul>
<h3 id="message-oriented-middleware">Message-oriented middleware</h3>
<ul>
<li>Queue managers</li>
<li>Message brokers
<ul>
<li>Transform and relay messages based on source and destination addresses and formats</li>
</ul>
</li>
<li>Multicast (Application level)
<ul>
<li>Link stress</li>
<li>Stretch</li>
</ul>
</li>
<li>Epidemic protocols
<ul>
<li>Anti-entropy</li>
<li>Rumor spreading</li>
</ul>
</li>
</ul>
<h3 id="restful-services">RESTful services</h3>
<ul>
<li>Usually via HTTP(S)</li>
<li>Messages can be XML, JSON, etc.</li>
<li>Based on URIs</li>
<li>Resources</li>
<li>CRUD operations</li>
</ul>
<p>CRUD:<br>
-Create<br>
-Run<br>
-Update<br>
-Delete<br>
Client-Server architecture<br>
-Seperating concers<br>
-UI from processing from data storage<br>
-Better scalability<br>
-Better support for migration, update, replace</p>
<p>Statelessness</p>
<ul>
<li>No client context stored in server between requests
<ul>
<li>State stored in the client</li>
<li>Can be also in the underlying DB</li>
<li>Client sends a request when changing state<br>
Cacheability: Messages have to define wheter they are cacheable or not -&gt; Perfomance improvements<br>
Layered system:</li>
</ul>
</li>
<li>Client cannot tell if it is talking to:
<ul>
<li>Gateway</li>
<li>Authentification server</li>
<li>Load balancer</li>
<li>App server<br>
Code on demand:</li>
</ul>
</li>
<li>Server can extend client by providing code<br>
Uniform interface:</li>
<li>Resource identification in request
<ul>
<li>Resource identified directly in the URI</li>
<li>Resource representation seperate from internal</li>
</ul>
</li>
<li>Resource manipulation through representation
<ul>
<li>Resource representation has enough info to manipulate it in the server</li>
</ul>
</li>
<li>Self-descriptive messages
<ul>
<li>Each messages has enough info to process it</li>
</ul>
</li>
<li>Hypermedia As The Engine Of Application State HATEOAS</li>
</ul>
<h4 id="rest-maturity-levels">REST Maturity levels</h4>
<ol start="0">
<li>Swamp of POX
<ul>
<li>Communicate over HTTP</li>
</ul>
</li>
<li>Resources
<ul>
<li>URI path already correct</li>
</ul>
</li>
<li>Verbs
<ul>
<li>URI Parameters now correct</li>
</ul>
</li>
<li>HATEOAS
<ul>
<li>Discoverability</li>
<li>Return all resources needed for future replies</li>
</ul>
</li>
</ol>
<h4 id="advantages-of-rest">Advantages of REST</h4>
<ul>
<li>Simple service</li>
<li>No state mismatch</li>
<li>Easy load balancing</li>
<li>Easy service comparison</li>
<li>Correct verbs make service clearer</li>
</ul>
<h4 id="naming-things">Naming things</h4>
<ul>
<li>Pure name – random string</li>
<li>Identifier – A name with a  specific property</li>
<li>Flat naming</li>
<li>Broadcasting</li>
<li>ARP</li>
<li>Forwarding pointer</li>
<li>Hierarchical locations services
<ul>
<li>Create hierarchies based on geographical data</li>
<li>Keyspaces create trees</li>
</ul>
</li>
<li>Structured naming
<ul>
<li>Each level defines its namespace</li>
<li>Attach attributes to any node</li>
<li>DNS</li>
<li>NFS file name</li>
<li>Phone number</li>
<li>IP address</li>
</ul>
</li>
<li>Links
<ul>
<li>Hard link – Point to another node</li>
<li>Soft link – Contain the name of another node</li>
</ul>
</li>
<li>Mounting</li>
<li>Foreign namespaces can be mounted in a node on the root namespace</li>
<li>Name spaces can be split among multiple machines in a distributed way</li>
<li>DNS name resolution (see Communication Systems)</li>
<li>UUIDs and GUIDs
<ul>
<li>Practically unique</li>
<li>No central coordination</li>
<li>128-bit identifiers</li>
<li>RFC 4122 defines uniform resource name</li>
</ul>
</li>
</ul>
<h3 id="coordination">Coordination</h3>
<ul>
<li>Clock coordination
<ul>
<li>NTP</li>
<li>UTC</li>
<li>Reference broadcast synchronization</li>
<li>Happened-before relationships</li>
</ul>
</li>
<li>Logical locks
<ul>
<li>Lamports clocks</li>
<li>Vector locks</li>
</ul>
</li>
<li>Mutual exclusion
<ul>
<li>Lamports clocks for mutual exclusion</li>
<li>Permission based
<ul>
<li>Coordinator decides who gets the lock</li>
</ul>
</li>
<li>Token based
<ul>
<li>Token-ring overlay network</li>
</ul>
</li>
<li>Mutual exclusion Ricart &amp; Agrawala</li>
<li>Decentralized algorithms</li>
</ul>
</li>
<li>Election algorithms
<ul>
<li>Find coordinators</li>
<li>All processes have unique IDs</li>
<li>All processes know of all other processes in the system</li>
<li>Election means identifying if the process with the highest ID is up</li>
<li>Elections in ring systems
<ul>
<li>Send a message on the ring with the ID</li>
<li>It goes around, and each node adds its ID</li>
</ul>
</li>
</ul>
</li>
<li>Positioning of a node
<ul>
<li>Calculate distance to landmarks</li>
<li>GPS</li>
</ul>
</li>
</ul>
<h3 id="replication">Replication</h3>
<ul>
<li>Reasons for replication
<ul>
<li>Reliability</li>
<li>Performance</li>
</ul>
</li>
</ul>
<h4 id="consistency">Consistency</h4>
<ul>
<li>Guaranteed consistency
<ul>
<li>Locking</li>
<li>Performance problems</li>
<li>Sequence locking</li>
</ul>
</li>
<li>Eventual consistency
<ul>
<li>Relaxed</li>
<li>The changes will be replicated to other replicas</li>
<li>This is not a locking call</li>
<li>Monotonic reads</li>
</ul>
</li>
</ul>
<h4 id="content-distribution">Content distribution</h4>
<ul>
<li>Propagate notification/invalidation</li>
<li>Transfer the data</li>
<li>Propagate the update operation</li>
</ul>
<h4 id="pull-vs-push">Pull vs push</h4>
<ul>
<li>Push
<ul>
<li>Server-initiated</li>
</ul>
</li>
<li>Pull
<ul>
<li>Client initiated poll</li>
</ul>
</li>
</ul>
<h4 id="replication-methods">Replication methods</h4>
<ul>
<li>Primary based
<ul>
<li>Primary handles all the writes</li>
<li>Primary has to sign off on all writes</li>
</ul>
</li>
</ul>
<h2 id="fault-tolerance">Fault tolerance</h2>
<h3 id="goals">Goals</h3>
<ul>
<li>Partial failure != total failure</li>
<li>Ideally failure means no degradation</li>
<li>If degradation is inevitable, it should degrade gracefully</li>
<li>In the case of catastrophic failure it should fail safely</li>
</ul>
<h3 id="dependability">Dependability</h3>
<ul>
<li>Parts of a system may depend on other parts of a system</li>
</ul>
<h3 id="metrics">Metrics</h3>
<ul>
<li>Availability</li>
<li>Reliability
<ul>
<li>MTTF (Mean Time To Failure)</li>
<li>MTTR (Mean Time To Repair)</li>
<li>MTBF (Mean Time Between Failures)</li>
</ul>
</li>
<li>Safety</li>
<li>Maintainability</li>
</ul>
<h3 id="terminology">Terminology</h3>
<ul>
<li>Failure - Symptom of the error</li>
<li>Error - Reason for failure</li>
<li>Fault - What created the error</li>
<li>Fault prevention - Prevent the occurrence of fault</li>
<li>Fault tolerance - Build the system in a way that it masks faults</li>
<li>Fault removal - Remove faults</li>
<li>Fault forecasting - Know of faults</li>
<li>Transient fault - Happens once, never again</li>
<li>Intermitten fault - Happens every once in a while</li>
<li>Permanent fault - Faulty until fixed</li>
</ul>
<h3 id="types-of-failures">Types of failures</h3>
<ul>
<li>Crash failure
<ul>
<li>Fail stop</li>
<li>Fail noisy</li>
<li>Fail silent</li>
<li>Fail safe</li>
<li>Fail arbitrary</li>
</ul>
</li>
<li>Omission failure</li>
<li>Timing failure</li>
<li>Response failure</li>
<li>Arbitrary failure
<ul>
<li>Omission failure</li>
<li>Commission failure</li>
</ul>
</li>
</ul>
<h3 id="async-and-sync-systems">Async and sync systems</h3>
<ul>
<li>Async system - Can not reliably detect crash failures</li>
<li>Synchronous system - Detect omission and timing failures</li>
<li>Partially synchronous systems - Can reliably detect crash failures</li>
</ul>
<h3 id="types-of-systems">Types of systems</h3>
<ul>
<li>Flat system</li>
<li>Hierarchical system</li>
</ul>
<h3 id="degree-of-fault-tolerance">Degree of fault-tolerance</h3>
<ul>
<li>k-fault tolerant = The system can work with k parts failing simultaneously</li>
</ul>
<h3 id="realistic-consensus-paxos">Realistic Consensus (Paxos)</h3>
<ul>
<li>Partially async system</li>
<li>Communication is unreliable</li>
<li>Corrupted messages detected</li>
<li>Operations are deterministic</li>
<li>Crash failures: yes; Arbitrary failures: no</li>
<li>Processes do not conclude</li>
</ul>
<h1 id="exam-stuff">Exam stuff</h1>
<ul>
<li>Partitioning / Distributed Hash Tables</li>
<li>High availability / Vector clocks</li>
<li>Failure tolerance / Sloppy Quorum</li>
<li>Permanent failures / Merkle trees (Hashes of hashes below)</li>
<li>Membership / Gossip-based membership protocol</li>
</ul>
<h3 id="networking">Networking</h3>
<ul>
<li>Point to Point connections</li>
<li>Transfer speeds of different protocols</li>
</ul>
<h4 id="slides">Slides</h4>
<ul>
<li>#4</li>
<li>#6</li>
<li>#10</li>
<li>#14-19</li>
<li>#22-23</li>
</ul>
<h3 id="security-1">Security</h3>
<ul>
<li>Know of AES (Chaining, block cypher)</li>
<li>Asymmetric encryption (RSA)</li>
<li>PKI, PGP</li>
<li>Hashing
<ul>
<li>Cryptographic hashing</li>
<li>Not the actual algorithms</li>
</ul>
</li>
<li>Usage of hashes</li>
<li>Authentication using IDP</li>
<li>Role-Based Access Control</li>
</ul>
<h4 id="slides-1">Slides</h4>
<ul>
<li>#3-5</li>
<li>#7-9</li>
<li>#11</li>
<li>#13-14-15</li>
<li>#18-20</li>
<li>#23-24</li>
<li>#27-28</li>
<li>#30-34</li>
</ul>
<h3 id="principles-architecture">Principles, Architecture</h3>
<ul>
<li>Openness</li>
<li>Problems of Scalability</li>
<li>Distribution
<ul>
<li>Data</li>
<li>Processing</li>
<li>Both</li>
<li>Layering vs Splitting</li>
</ul>
</li>
<li>Types of distributed computing
<ul>
<li>Cluster computing - Fast interconnect, identical machines</li>
<li>Cloud computing - Heterogenious system, internet</li>
</ul>
</li>
<li>ACID Principle</li>
<li>Communication types
<ul>
<li>RPC, RMI, MOM</li>
</ul>
</li>
<li>Health care</li>
<li>Layered, Object-based, Event-based</li>
<li>System architectures
<ul>
<li>Layering -&gt; Fat clients, thin clients</li>
</ul>
</li>
<li>Decentralized architectures</li>
<li>Peer-to-Peer architectures
<ul>
<li>Machines organized into an overlay network</li>
<li>Structured P2P -&gt; DHT</li>
<li>Unstructured P2P -&gt; Flooding / Low performance</li>
</ul>
</li>
<li>Middleware vs Architecture
<ul>
<li>Middleware -&gt; Software that implements architecture</li>
</ul>
</li>
</ul>
<h4 id="slides-2">Slides</h4>
<ul>
<li>#6-8</li>
<li>#10</li>
<li>#11-14</li>
<li>#18-22</li>
<li>#24</li>
<li>#28-29</li>
<li>#32-34</li>
<li>#36</li>
</ul>
<h3 id="processes">Processes</h3>
<ul>
<li>Multithreaded systems -&gt; Parallel communication</li>
<li>Server-side should be multi-threaded to serve multiple clients at the same time</li>
<li>Virtualization</li>
<li>Cloud computing models</li>
<li>Middleware to handle distributed concepts</li>
<li>Out of band communication</li>
<li>Stateless servers vs stateful servers</li>
<li>Three tier architecture</li>
<li>Migration</li>
</ul>
<h4 id="slides-3">Slides</h4>
<ul>
<li>#12</li>
<li>#14</li>
<li>#16</li>
<li>#21</li>
<li>#22</li>
<li>#29</li>
<li>#31-32</li>
<li>#34</li>
<li>#47</li>
</ul>
<h3 id="restful-services-1">RESTful services</h3>
<ul>
<li>REST architecture constraints
<ul>
<li>Statelessness</li>
<li>Uniform interface</li>
<li>HTTP verbs</li>
</ul>
</li>
</ul>
<h4 id="slides-4">Slides</h4>
<ul>
<li>#2-3</li>
<li>#10</li>
<li>#17-18</li>
</ul>
<h3 id="communications">Communications</h3>
<ul>
<li>Transient / Persistent</li>
<li>Asynchronous / Synchronous</li>
<li>Message oriented middleware</li>
<li>RPC framework</li>
<li>RPC parameter passing</li>
<li>Message-oriented middleware</li>
<li>Application level multicasting</li>
<li>Epidemic protocols
<ul>
<li>Anti-entropy</li>
<li>Rumor-spreading</li>
</ul>
</li>
</ul>
<h4 id="slides-5">Slides</h4>
<ul>
<li>#5</li>
<li>#7</li>
<li>#11-12</li>
<li>#14</li>
<li>#29</li>
<li>#37</li>
<li>#41</li>
</ul>
<h3 id="naming-things-1">Naming things</h3>
<ul>
<li>Home address</li>
<li>Distributed Hash table
<ul>
<li>Logical ring</li>
<li>Finger tables</li>
</ul>
</li>
<li>Namespace systems</li>
<li>Mounting</li>
<li>LDAP</li>
<li>UUID, GUID</li>
</ul>
<h4 id="slides-6">Slides</h4>
<ul>
<li>#11</li>
<li>#23-24</li>
<li>#28</li>
<li>#39</li>
</ul>
<h4 id="uuidguid">UUID/GUID</h4>
<ul>
<li>#2</li>
<li>#4</li>
</ul>
<h3 id="coordination-1">Coordination</h3>
<ul>
<li>Happened-before relationship</li>
<li>Logical clocks</li>
<li>Total ordered multicast -&gt; Timestamp+ack
<ul>
<li>Assures everything in order</li>
<li>High performance penalty</li>
</ul>
</li>
<li>Vector clocks</li>
<li>Capturing causality</li>
<li>Mutual exclusion</li>
<li>Election algorithms
<ul>
<li>Election by bullying</li>
</ul>
</li>
</ul>
<h4 id="slides-7">Slides</h4>
<ul>
<li>#8</li>
<li>#11</li>
<li>#12</li>
<li>#14</li>
<li>#20</li>
<li>#24</li>
<li>#33</li>
</ul>
<h3 id="consistency-and-replication">Consistency and Replication</h3>
<ul>
<li>Reasons for replication</li>
<li>Performance and scalability</li>
<li>Weakened consistency requirements</li>
<li>Sequential consistency</li>
<li>Eventual consistency</li>
<li>BASE instead of ACID</li>
<li>Client-centric consistency
<ul>
<li>It doesn’t matter if the system is consistent, if the client <em>thinks</em> the system is consistent</li>
</ul>
</li>
<li>Content replication</li>
<li>Content distribution
<ul>
<li>Propagating updates</li>
</ul>
</li>
<li>Push/Pull updates</li>
<li>Quorum-based approach</li>
</ul>
<h4 id="slides-8">Slides</h4>
<ul>
<li>#4</li>
<li>#10-11</li>
<li>#14</li>
<li>#25</li>
<li>#28-29</li>
<li>#37</li>
</ul>
<h3 id="fault-tolerance-1">Fault tolerance</h3>
<ul>
<li>Availability vs Reliability</li>
<li>Fault prevention</li>
<li>Fault tolerance</li>
<li>Fault removal</li>
<li>Fault types</li>
<li>Process resilience</li>
<li>Degree of fault-tolerance</li>
<li>CAP theorem</li>
<li>2PC</li>
<li>Error recovery
<ul>
<li>Recovery points</li>
<li>Checkpointing</li>
</ul>
</li>
<li>Message logging</li>
</ul>
<h4 id="slides-9">Slides</h4>
<ul>
<li>#3</li>
<li>#7-8</li>
<li>#14</li>
<li>#40</li>
<li>#53-54</li>
<li>#61</li>
<li>#65</li>
</ul>

    </div>
  </div>
</body>

</html>
